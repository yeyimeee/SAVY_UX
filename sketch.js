let img_navbar, img_infoBanner, img_map, img_footer, img_aiIcon, img_olisten, img_otalk, img_tOutput, img_frame;
let table, csvText = "", userSpeechText = "", state = 0;
let scrollOffset = 0, maxScroll = 0;
let apiKey = "AIzaSyD3KbVer5qm207UfKpc3wzOXoACbVCzCCI";
let conversationHistory = [], userHistory = [], aiHistory = [];
let ai_response = "", parsedDisasters = [];
let svgMapDiv, svgContent = "", seoulDistricts = {};

const systemPrompt = "ÎãπÏã†ÏùÄ Ïû¨ÎÇúÏïàÏ†Ñ Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§. Ï†úÍ≥µÎêú CSV Îç∞Ïù¥ÌÑ∞Î•º Î∞îÌÉïÏúºÎ°ú ÏßàÎ¨∏Ïóê Ï†ïÌôïÌïòÍ≤å ÏùëÎãµÌïòÏÑ∏Ïöî. ÏùëÎãµ ÌòïÏãù Í∑úÏπô: 1. ÏùëÎãµÏùÄ Î∞òÎìúÏãú Íµ¨(ÂçÄ) Îã®ÏúÑÎ°ú Íµ¨Î∂ÑÎêú Îã®ÎùΩÏúºÎ°ú Íµ¨ÏÑ±Ìï©ÎãàÎã§. 2. Í∞Å Îã®ÎùΩÏùÄ Î∞òÎìúÏãú [ÏãúÏù¥Î¶Ñ]Ïãú [Íµ¨Ïù¥Î¶Ñ]Íµ¨Î°ú ÏãúÏûëÌï©ÎãàÎã§ (Ïòà: ÏÑúÏö∏ÌäπÎ≥ÑÏãú Í∞ïÎÇ®Íµ¨).. 3. Í∞Å Îã®ÎùΩ ÎÇ¥ Ïû¨ÎÇú Ïú†ÌòïÏùÄ Îã§Ïùå Ï§ë ÌïòÎÇòÎ°ú Î™ÖÌôïÌûà ÌëúÏãúÌï©ÎãàÎã§:  ÌôîÏû¨ | ÏÇ∞ÏÇ¨ÌÉú | Í∞ïÌíçÏ£ºÏùòÎ≥¥ | Í∞ïÌíç | Ïã±ÌÅ¨ÌôÄ | ÏßëÏ§ëÌò∏Ïö∞ | Ìò∏Ïö∞ 4. Ïû¨ÎÇú ÏÑ§Î™ÖÏùÄ 2Î¨∏Ïû•ÏúºÎ°ú Í∞ÑÍ≤∞Ìûà ÏöîÏïΩÌï©ÎãàÎã§. 5. Î™®Îì† Ïû¨ÎÇú ÏÑ§Î™ÖÏùÄ ÏÑúÏö∏ÌäπÎ≥ÑÏãú OOÍµ¨ ÌòïÏãùÏúºÎ°ú ÏãúÏûëÌï¥Ïïº Ìï©ÎãàÎã§.(ÎßêÌà¨Îäî ~Îã§ Î≥¥Îã§Îäî ~Ïöî Ï≤¥Î°ú ÏπúÍ∑ºÌïòÍ≤å ÏùëÎãµÌïòÎ©∞ ÏßàÎ¨∏Ïóê ÏùëÎãµÌï† ÎïåÎäî ÏßÄÏó≠Î™ÖÏùÑ Îã§Ïãú Ìïú Î≤à Ïñ∏Í∏âÌïòÍ≥† Ìï¥Îãπ ÏßÄÏó≠Ïùò Ïû¨ÎÇúÎ¨∏Ïûê ÎÇ¥Ïö©ÏùÑ 2Î¨∏Ïû•ÏúºÎ°ú Í∞ÑÎûµÌïòÍ≤å ÏÑ§Î™ÖÌïòÎ©∞ ÏÇ¨Ïö©ÏûêÏóêÍ≤å Ï£ºÏùò/Í≤ΩÍ≥†Î•º Ï£ºÏÑ∏Ïöî.) ÏòàÏãú ÏùëÎãµ Íµ¨Ï°∞: Ï§ëÍµ¨ \nÏßëÏ§ëÌò∏Ïö∞Î°ú Ïù∏Ìïú Ïπ®Ïàò ÌîºÌï¥Í∞Ä Ïö∞Î†§Îê©ÎãàÎã§. Ïô∏Ï∂úÏùÑ ÏûêÏ†úÌïòÏãúÍ≥† ÎåÄÎπÑÌïòÏÑ∏Ïöî. \n 2025ÎÖÑ 5Ïõî 20Ïùº Î∞úÏÉù. 6. Í∏àÏßÄÏÇ¨Ìï≠: 1. Ïû¨ÎÇú Î¨∏ÏûêÍ∞Ä Î∞úÏÜ°ÎêòÏóàÏñ¥Ïöî Í∞ôÏùÄ ÌëúÌòÑ ÏÇ¨Ïö© Í∏àÏßÄ 2. Î≥ÑÌëú(**) ÏÇ¨Ïö© Í∏àÏßÄ, (*)ÎèÑ ÏÇ¨Ïö© Í∏àÏßÄ 3. ÏßÄÏó≠ Íµ¨Î∂Ñ Ïãú Ìïú Ï§Ñ ÎùÑÏö∞Í∏∞";

const disasterColors = {
  "ÌôîÏû¨": "#D4480E",
  "ÏÇ∞ÏÇ¨ÌÉú": "#ECD052",
  "Í∞ïÌíç": "#429946",
  "Ïã±ÌÅ¨ÌôÄ": "#885D2F",
  "ÏßëÏ§ëÌò∏Ïö∞": "#214FF3"
};

// üéØ ÏàòÏ†ïÎêú ÏÑúÏö∏Ïãú 25Í∞ú Íµ¨Ïùò Ï§ëÏã¨ Ï¢åÌëú (Ïã§Ï†ú SVG Ï¢åÌëúÍ≥ÑÏóê ÎßûÍ≤å Ï°∞Ï†ï)
const districtCenters = {
  "Í∞ïÎÇ®Íµ¨": { x: 0.665, y: 0.72 },    // ÎπÑÏú®Î°ú ÌëúÌòÑ (0~1)
  "Í∞ïÎèôÍµ¨": { x: 0.882, y: 0.57 },
  "Í∞ïÎ∂ÅÍµ¨": { x: 0.592, y: 0.27 },
  "Í∞ïÏÑúÍµ¨": { x: 0.15, y: 0.5 },
  "Í¥ÄÏïÖÍµ¨": { x: 0.43, y: 0.82 },
  "Í¥ëÏßÑÍµ¨": { x: 0.75, y: 0.6 },
  "Íµ¨Î°úÍµ¨": { x: 0.2, y: 0.72 },
  "Í∏àÏ≤úÍµ¨": { x: 0.3, y: 0.8 },
  "ÎÖ∏ÏõêÍµ¨": { x: 0.75, y: 0.3 },
  "ÎèÑÎ¥âÍµ¨": { x: 0.63, y: 0.2 },
  "ÎèôÎåÄÎ¨∏Íµ¨": { x: 0.67, y: 0.46 },
  "ÎèôÏûëÍµ¨": { x: 0.44, y: 0.7 },
  "ÎßàÌè¨Íµ¨": { x: 0.35, y: 0.54 },
  "ÏÑúÎåÄÎ¨∏Íµ¨": { x: 0.4, y: 0.48 },
  "ÏÑúÏ¥àÍµ¨": { x: 0.58, y: 0.8 },
  "ÏÑ±ÎèôÍµ¨": { x: 0.65, y: 0.57 },
  "ÏÑ±Î∂ÅÍµ¨": { x: 0.6, y: 0.4 },
  "ÏÜ°ÌååÍµ¨": { x: 0.8, y: 0.7 },
  "ÏñëÏ≤úÍµ¨": { x: 0.22, y: 0.65 },
  "ÏòÅÎì±Ìè¨Íµ¨": { x: 0.345, y: 0.65 },
  "Ïö©ÏÇ∞Íµ¨": { x: 0.5, y: 0.6 },
  "ÏùÄÌèâÍµ¨": { x: 0.4, y: 0.35 },
  "Ï¢ÖÎ°úÍµ¨": { x: 0.537, y: 0.47 },
  "Ï§ëÍµ¨": { x: 0.55, y: 0.53 },
  "Ï§ëÎûëÍµ¨": { x: 0.78, y: 0.4 }
};

function preload() {
  img_navbar = loadImage('NavBar.png');
  img_infoBanner = loadImage('InfoBanner.png');
  img_map = loadImage('Map.png');
  img_footer = loadImage('Footer.png');
  img_aiIcon = loadImage('aiIcon.png');
  img_olisten = loadImage('Orange_listen.png');
  img_otalk = loadImage('Orange_talk.png');
  img_tOutput = loadImage('talkOutput_ai.png');
  img_frame = loadImage('Frame.png');
  table = loadTable("Í∏¥Í∏âÏû¨ÎÇúÎ¨∏Ïûê.csv", "csv", "header");

  httpGet('seoul.svg', 'text', (data) => {
    svgContent = data;
    parseSVGData();
  }, (error) => {
    console.error("SVG Î°úÎìú Ïã§Ìå®:", error);
  });
}

function parseSVGData() {
  if (!svgContent) return;
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(svgContent, "image/svg+xml");
  const paths = xmlDoc.getElementsByTagName('path');
  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];
    const id = path.getAttribute('id');
    if (id && id.includes('Íµ¨')) {
      seoulDistricts[id] = {
        id: id,
        originalFill: path.getAttribute('fill') || '#C8C8C8'
      };
    }
  }
}

function setup() {
  createCanvas(393, 852);
  if (!("webkitSpeechRecognition" in window)) {
    noLoop();
  } else {
    speechRecognition = new webkitSpeechRecognition();
    speechRecognition.lang = "ko-KR";
    speechRecognition.continuous = true;
    speechRecognition.onresult = speechResult;
  }
  for (let r = 0; r < table.getRowCount(); r++) {
    let rowStr = "";
    for (let c = 0; c < table.getColumnCount(); c++) {
      rowStr += table.columns[c] + ": " + table.getString(r, c) + "\n";
    }
    csvText += rowStr + "\n";
  }
}

function draw() {
  background(255);

  if (state === 0) {
    image(img_navbar, 0, 0, 393, 124);
    image(img_infoBanner, 0, 124, 393, 287);
    image(img_map, 0, 411, 393, 276);
    image(img_footer, 0, 687, 393, 165);
    image(img_aiIcon, 303, 700, 80, 80);

  } else if (state === 1) {
    image(img_navbar, 0, 0, 393, 124);
    image(img_infoBanner, 0, 124, 393, 287);
    image(img_map, 0, 411, 393, 276);
    image(img_footer, 0, 687, 393, 165);
    image(img_aiIcon, 303, 700, 80, 80);
    image(img_olisten, 0, 0, 393, 852);

  } else if (state === 2) {
    image(img_navbar, 0, 0, 393, 124);
    image(img_infoBanner, 0, 124, 393, 287);
    image(img_map, 0, 411, 393, 276);
    image(img_footer, 0, 687, 393, 165);
    image(img_aiIcon, 303, 700, 80, 80);
    image(img_otalk, 0, 0, 393, 852);
    image(img_tOutput, 22, 228, 359, 596);

    let inputText = userSpeechText || "ÏßàÎ¨∏ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî";
    drawUserBubble(inputText);
    drawAIResponse();

    if (ai_response && ai_response.length > 0) {
      drawMapButton();
    }

  } else if (state === 3) {
    drawMapView();
  }
}

function drawUserBubble(inputText) {
  textSize(14);
  textAlign(LEFT, TOP);
  textWrap(WORD);

  let maxBubbleWidth = 359;
  let padding = 20;
  let lineHeight = 20;

  let tempWords = inputText.split(' ');
  let lines = [];
  let line = "";

  for (let i = 0; i < tempWords.length; i++) {
    let testLine = line + tempWords[i] + " ";
    if (textWidth(testLine) > maxBubbleWidth - padding * 2) {
      lines.push(line.trim());
      line = tempWords[i] + " ";
    } else {
      line = testLine;
    }
  }
  lines.push(line.trim());

  let bubbleHeight = lines.length * lineHeight + padding * 2;
  let bubbleWidth = 0;
  for (let l of lines) {
    bubbleWidth = max(bubbleWidth, textWidth(l));
  }
  bubbleWidth = min(bubbleWidth + padding * 2, maxBubbleWidth);

  let shadowColor = color(0x86, 0xC2, 0x6F, 204);
  fill(shadowColor);
  noStroke();
  rect(24, 142, bubbleWidth, bubbleHeight, 50);

  fill('#FA7910');
  noStroke();
  rect(24, 138, bubbleWidth, bubbleHeight, 50);

  let textTotalHeight = lines.length * lineHeight;
  let textStartY = 138 + (bubbleHeight - textTotalHeight) / 2;

  fill(255);
  for (let l of lines) {
    text(l, 24 + padding, textStartY);
    textStartY += lineHeight;
  }
}

function drawAIResponse() {
  let clipX = 47;
  let clipY = 255;
  let clipW = 300;
  let clipH = 350;

  textSize(14);
  textAlign(LEFT, TOP);
  textWrap(WORD);

  let aiLines = [];
  if (ai_response && ai_response.length > 0) {
    let tempLines = ai_response.split('\n');
    for (let i = 0; i < tempLines.length; i++) {
      let words = tempLines[i].split(' ');
      let l = '';
      for (let j = 0; j < words.length; j++) {
        let testL = l + words[j] + ' ';
        if (textWidth(testL) > clipW) {
          aiLines.push(l);
          l = words[j] + ' ';
        } else {
          l = testL;
        }
      }
      aiLines.push(l);
    }
  }

  let lineHeight = 20;
  let totalHeight = aiLines.length * lineHeight;
  maxScroll = max(0, totalHeight - clipH);
  scrollOffset = constrain(scrollOffset, 0, maxScroll);

  fill(255);
  for (let i = 0; i < aiLines.length; i++) {
    let y = clipY + i * lineHeight - scrollOffset;
    if (y >= clipY && y < clipY + clipH) {
      text(aiLines[i], clipX, y);
    }
  }

  if (totalHeight > clipH) {
    let scrollbarH = map(clipH, 0, totalHeight, 30, clipH);
    let scrollbarY = map(scrollOffset, 0, maxScroll, 0, clipH - scrollbarH);
    fill(200);
    noStroke();
    rect(clipX + clipW + 5, clipY + scrollbarY, 4, scrollbarH, 2);
  }
}

function drawMapButton() {
  let buttonX = 70;
  let buttonY = 620;
  let buttonW = 250;
  let buttonH = 40;

  fill('#4CAF50');
  noStroke();
  rect(buttonX, buttonY, buttonW, buttonH, 20);

  fill(255);
  textAlign(CENTER, CENTER);
  textSize(16);
  text("ÏßÄÎèÑÏóêÏÑú ÌôïÏù∏ÌïòÍ∏∞", buttonX + buttonW/2, buttonY + buttonH/2);
}

function drawMapView() {
  background(245);

  fill('#FA7910');
  rect(0, 0, width, 60);
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(18);
  text("ÏÑúÏö∏Ïãú Ïû¨ÎÇú ÌòÑÌô© ÏßÄÎèÑ", width/2, 30);

  fill(255);
  rect(10, 15, 60, 30, 5);
  fill(0);
  textSize(14);
  text("< Ïù¥Ï†Ñ ", 40, 30);

  if (!svgMapDiv && svgContent) {
    createSVGMap();
  }

  drawBottomLegend();
}

function createSVGMap() {
  if (!svgContent) return;
  if (svgMapDiv) svgMapDiv.remove();

  const headerHeight = 80;
  const legendHeight = 60;
  const padding = 0;

  const mapAreaX = 0;
  const mapAreaY = headerHeight;
  const mapAreaWidth = width;
  const mapAreaHeight = height - headerHeight - legendHeight;

  svgMapDiv = createDiv('').id('svg-map-container');
  svgMapDiv.position(mapAreaX, mapAreaY);
  svgMapDiv.size(mapAreaWidth, mapAreaHeight);
  svgMapDiv.style('overflow', 'hidden');
  svgMapDiv.style('pointer-events', 'none');
  svgMapDiv.style('display', 'flex');
  svgMapDiv.style('align-items', 'center');
  svgMapDiv.style('justify-content', 'center');
  svgMapDiv.style('background', 'none');
  svgMapDiv.style('border', 'none');
  svgMapDiv.style('box-shadow', 'none');

  svgMapDiv.html(svgContent);

  const svgElement = document.querySelector('#svg-map-container svg');
  if (svgElement) {
    const svgWidth = svgElement.viewBox?.baseVal?.width || svgElement.width?.baseVal?.value || 1000;
    const svgHeight = svgElement.viewBox?.baseVal?.height || svgElement.height?.baseVal?.value || 800;

    const scaleX = mapAreaWidth / svgWidth;
    const scaleY = mapAreaHeight / svgHeight;
    const optimalScale = Math.min(scaleX, scaleY);

    const scaledWidth = svgWidth * optimalScale;
    const scaledHeight = svgHeight * optimalScale;
    const offsetX = (mapAreaWidth - scaledWidth) / 2;
    const offsetY = (mapAreaHeight - scaledHeight) / 2;

    svgElement.style.width = scaledWidth + 'px';
    svgElement.style.height = scaledHeight + 'px';
    svgElement.style.position = 'absolute';
    svgElement.style.left = offsetX + 'px';
    svgElement.style.top = offsetY + 'px';
    svgElement.style.border = 'none';
    svgElement.style.borderRadius = '0';
    svgElement.style.boxShadow = 'none';
    svgElement.style.background = 'none';

    // üéØ ÏàòÏ†ïÎêú Íµ¨ Ïù¥Î¶Ñ ÎùºÎ≤® Ï∂îÍ∞Ä (Ï†ïÌôïÌïú ÏúÑÏπò Í≥ÑÏÇ∞)
    setTimeout(() => {
      addDistrictLabels(mapAreaX + offsetX, mapAreaY + offsetY, scaledWidth, scaledHeight);
    }, 100);
  }
}

// üéØ ÌïµÏã¨ ÏàòÏ†ï: ÎπÑÏú® Í∏∞Î∞ò Ï¢åÌëúÎ°ú Ï†ïÌôïÌïú ÌÖçÏä§Ìä∏ ÏúÑÏπò Í≥ÑÏÇ∞
function addDistrictLabels(mapX, mapY, mapWidth, mapHeight) {
  const svgContainer = document.querySelector('#svg-map-container');
  if (!svgContainer) return;

  // Í∏∞Ï°¥ ÎùºÎ≤® Ï†úÍ±∞
  const existingLabels = svgContainer.querySelectorAll('.district-label');
  existingLabels.forEach(label => label.remove());

  // Í∞Å Íµ¨Ïùò Ï§ëÏã¨Ïóê ÌÖçÏä§Ìä∏ ÎùºÎ≤® Ï∂îÍ∞Ä (ÎπÑÏú® Í∏∞Î∞ò ÏúÑÏπò Í≥ÑÏÇ∞)
  for (let districtName in districtCenters) {
    const center = districtCenters[districtName];
    
    // ÎπÑÏú®(0~1)ÏùÑ Ïã§Ï†ú ÌîΩÏÖÄ Ï¢åÌëúÎ°ú Î≥ÄÌôò
    const absoluteX = mapX + (center.x * mapWidth);
    const absoluteY = mapY + (center.y * mapHeight);

    // HTML div ÏöîÏÜåÎ°ú ÌÖçÏä§Ìä∏ ÎùºÎ≤® ÏÉùÏÑ±
    const label = document.createElement('div');
    label.className = 'district-label';
    label.textContent = districtName;
    label.style.position = 'absolute';
    label.style.left = absoluteX + 'px';
    label.style.top = absoluteY + 'px';
    label.style.transform = 'translate(-50%, -50%)'; // Ï§ëÏïô Ï†ïÎ†¨
    label.style.fontSize = Math.max(10, Math.min(14, mapWidth / 30)) + 'px'; // Î∞òÏùëÌòï ÌÅ¨Í∏∞
    label.style.fontWeight = 'bold';
    label.style.color = '#333';
    label.style.textShadow = '2px 2px 4px white, -2px -2px 4px white, 2px -2px 4px white, -2px 2px 4px white';
    label.style.pointerEvents = 'none';
    label.style.userSelect = 'none';
    label.style.zIndex = '1000';
    label.style.whiteSpace = 'nowrap';

    document.body.appendChild(label); // bodyÏóê ÏßÅÏ†ë Ï∂îÍ∞Ä
    
    console.log(`ÎùºÎ≤® ÏúÑÏπò: ${districtName} - (${absoluteX.toFixed(0)}, ${absoluteY.toFixed(0)})`);
  }
}

function drawBottomLegend() {
  const legendY = height - 55;
  const legendHeight = 45;
  const padding = 10;

  fill(255, 240);
  stroke(100);
  strokeWeight(1);
  rect(padding, legendY, width - padding * 2, legendHeight, 8);

  fill(0);
  textAlign(LEFT, CENTER);
  textSize(12);
  textStyle(BOLD);
  text("Ïû¨ÎÇú Ïú†Ìòï:", padding + 10, legendY + legendHeight / 2);

  const disasterTypes = Object.keys(disasterColors);
  const startX = padding + 80;
  const itemWidth = (width - startX - padding - 20) / disasterTypes.length;

  textStyle(NORMAL);
  textSize(9);

  for (let i = 0; i < disasterTypes.length; i++) {
    const disaster = disasterTypes[i];
    const x = startX + i * itemWidth;
    const centerY = legendY + legendHeight / 2;

    fill(disasterColors[disaster]);
    noStroke();
    rect(x, centerY - 6, 12, 12, 2);

    fill(0);
    textAlign(LEFT, CENTER);
    text(disaster, x + 16, centerY);
  }

  fill(100);
  textSize(8);
  textStyle(ITALIC);
  textAlign(CENTER, CENTER);
  text("Ïû¨ÎÇú Î∞úÏÉù Íµ¨Ïó≠ÏùÄ Ìï¥Îãπ ÏÉâÏÉÅÏúºÎ°ú ÌëúÏãúÎê©ÎãàÎã§", width/2, legendY + legendHeight - 8);
}

function parseDisasterInfo(response) {
  let disasters = [];
  const paragraphs = response.split('\n\n');
  for (const para of paragraphs) {
    const districtMatch = para.match(/([Í∞Ä-Ìû£]+Ïãú)\s*([Í∞Ä-Ìû£]+Íµ¨)/);
    if (!districtMatch) continue;
    const district = districtMatch[2];
    const disasterMatch = para.match(/(ÌôîÏû¨|ÏÇ∞ÏÇ¨ÌÉú|Í∞ïÌíçÏ£ºÏùòÎ≥¥|Í∞ïÌíç|Ïã±ÌÅ¨ÌôÄ|ÏßëÏ§ëÌò∏Ïö∞|Ìò∏Ïö∞)/g);
    if (disasterMatch) {
      const cleanedDisasters = new Set();
      for (const d of disasterMatch) {
        const cleanD = d.replace(/\s+/g, '');
        if (cleanD === 'Í∞ïÌíçÏ£ºÏùòÎ≥¥' || cleanD === 'Í∞ïÌíç') {
          cleanedDisasters.add('Í∞ïÌíç');
        } else if (cleanD === 'Ìò∏Ïö∞') {
          cleanedDisasters.add('ÏßëÏ§ëÌò∏Ïö∞');
        } else {
          cleanedDisasters.add(cleanD);
        }
      }
      for (const disaster of cleanedDisasters) {
        disasters.push({ district, disaster });
      }
    }
  }
  console.log("=== ÌååÏã±Îêú Ïû¨ÎÇú Ï†ïÎ≥¥ (ÌÜµÌï©) ===");
  console.table(disasters);
  return disasters;
}

function colorDistricts() {
  const svgContainer = document.querySelector('#svg-map-container');
  if (!svgContainer) {
    console.error("SVG Ïª®ÌÖåÏù¥ÎÑàÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§");
    return;
  }
  const svgElement = svgContainer.querySelector('svg');
  if (!svgElement) {
    console.error("SVG ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§");
    return;
  }
  const paths = svgElement.querySelectorAll('path[id]');

  paths.forEach(path => {
    path.setAttribute('fill', '#C8C8C8');
    path.setAttribute('stroke', '#666');
    path.setAttribute('stroke-width', '1');
  });

  for (let info of parsedDisasters) {
    const path = svgElement.querySelector(`path[id="${info.district}"]`);
    if (path && disasterColors[info.disaster]) {
      path.setAttribute('fill', disasterColors[info.disaster]);
      path.setAttribute('stroke', '#000');
      path.setAttribute('stroke-width', '2');
      console.log(`ÏÉâÏπ† ÏôÑÎ£å: ${info.district} -> ${disasterColors[info.disaster]}`);
    } else {
      console.error(`‚ùå pathÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: ${info.district}`);
    }
  }
}

function updateMapData() {
  parsedDisasters = parseDisasterInfo(ai_response);
  if (parsedDisasters.length > 0) {
    setTimeout(() => colorDistricts(), 500);
  }
}

function mouseClicked() {
  if (mouseX >= 320 && mouseX <= 380 && mouseY >= 688 && mouseY <= 748) {
    if (state === 0 || state === 2 || state === 3) {
      state = 1;
      userSpeechText = "";
      ai_response = "";
      startSpeechRecognition();
    } else if (state === 1) {
      state = 2;
      if (ai_response) {
        speakText(ai_response);
      }
    }
  }
  if (state === 2 && mouseX >= 70 && mouseX <= 320 && mouseY >= 620 && mouseY <= 660) {
    updateMapData();
    state = 3;
  }
  if (state === 3 && mouseX >= 10 && mouseX <= 70 && mouseY >= 15 && mouseY <= 45) {
    // ÎùºÎ≤® Ï†ïÎ¶¨
    const labels = document.querySelectorAll('.district-label');
    labels.forEach(label => label.remove());
    
    if (svgMapDiv) {
      svgMapDiv.remove();
      svgMapDiv = null;
    }
    state = 2;
  }
}

function startSpeechRecognition() {
  if (speechRecognition) {
    speechRecognition.start();
  }
}

function speechResult(event) {
  try {
    let speechInput = Array.from(event.results)
      .map((result) => result[0].transcript)
      .join("");
    if (event.results[event.results.length - 1].isFinal) {
      userSpeechText = speechInput;
      speechRecognition.stop();
      generateResponse(speechInput);
    }
  } catch (error) {
    console.error("speechResult Ïò§Î•ò:", error);
  }
}

async function generateResponse(question) {
  const url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=" + apiKey;
  conversationHistory = [
    {
      role: "user",
      parts: [{ text: systemPrompt + "\n\nCSV Îç∞Ïù¥ÌÑ∞:\n" + csvText }]
    },
    {
      role: "user",
      parts: [{ text: question }]
    }
  ];
  userHistory.push(question);

  let requestBody = {
    system_instruction: { parts: [{ text: systemPrompt }] },
    contents: conversationHistory
  };

  try {
    let response = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error("API error: " + response.status + " - " + errorText);
    }

    let data = await response.json();

    if (data.candidates && data.candidates.length > 0) {
      ai_response = data.candidates[0].content.parts[0].text.replaceAll("**", "");
    } else {
      ai_response = "ÎãµÎ≥ÄÏùÑ Î∞õÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.";
    }
    state = 2;
    speakText(ai_response);
    aiHistory.push(ai_response);
    conversationHistory.push({
      role: "model",
      parts: [{ text: ai_response }]
    });
  } catch (error) {
    ai_response = "AI ÏùëÎãµ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: " + error.message;
    state = 2;
  }
}

async function speakText(text) {
  let ttsUrl = "https://texttospeech.googleapis.com/v1/text:synthesize?key=" + apiKey;
  let requestBody = {
    audioConfig: {
      audioEncoding: "MP3",
      effectsProfileId: ["telephony-class-application"],
      pitch: 0,
      speakingRate: 1
    },
    input: { text: text },
    voice: {
      languageCode: "ko-KR",
      name: "ko-KR-Standard-A"
    }
  };
  try {
    let response = await fetch(ttsUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error("TTS error: " + response.status + " - " + errorText);
    }
    let data = await response.json();
    if (data.audioContent) {
      let audioData = "data:audio/mp3;base64," + data.audioContent;
      let audio = new Audio(audioData);
      audio.oncanplaythrough = () => audio.play();
      audio.play();
    }
  } catch (error) {
    // Î¨¥Ïùå Ï≤òÎ¶¨
  }
}

function mouseWheel(event) {
  if (state === 2) {
    scrollOffset += event.delta / 2;
    scrollOffset = constrain(scrollOffset, 0, maxScroll);
    return false;
  }
}
